## Formal2019_Practice1
Практикум. Вариант 12. Колпакчи Мирра 827
### Задача:
Дано регулярное выражение в обратной польской записи и слово u. Найти длину самого длинного суффикса u, принадлежащего L.
### Структура вершины:
Автомат - граф, с вершинами Vertex, которые хранят все исходящие ребра вершины (в виде вектора пар адреса вершины и символа на ребре), и bool finish(является ли вершина конечной в автомате).
### Класс Автомат:
Автомат мы храним в виде класса, в котором хранятся стартовая вершина, список конечных вершин, реализована структура Vertex, функции для операций над автоматами, а также функции поиска самого длинного суффикса и проверки корректности подаваемого регулярного выражения.
### Построение автомата по символу:
Создаем две новые вершины. Одну из них обозначаем стартовой, другую - конечной. Конечную добовляем в список конечных вершин. Соединяем стартовую и конечную вершину ребром со значением, данным на входе.
### Операция *:
Это унарная операция. Для реализации мы делаем стартовую вершину конечной, и из всех конечных вершин автомата создаем Е-переход в стартовую. Результатом будет автомат со всеми изменениями
### Операция +:
Это бинарная операция. Для реализации мы делаем из стартовой вершины первого автомата создаем идентичные ребра для всех сыновей стартовой вершины второго. Результатом будет автомат со стартовой вершиной первого автомата и конечными вершинами первого и второго.
### Операция .:
Это бинарная операция. Для реализации мы все конечные вершины первого автомата делаем не конечными и присваиваем каждой из них всех сыновей стартовой вершины второго автомата. В случае, если у вершин ворого автомата есть в ребра в их стартовую вершину, то мы удаляем эти ребра и создаем идентичные во все конечные вершины первого автомата. В случае, если стартовая вершина второго автомата была конечной, то мы оставляем конечными конечные вершины первого. Результатом будет автомат со стартовой вершиной первого автомата, конечными вершинами второго(измененными, если была необходимость) и всеми проделанными изменениями.
### Построение автомата по регулярному выражению в обратной польской записи:
Читаем посимвольно регулярное выражение. Если это ’a’, ’b’, ’c’ или ’1’, то строи по нему автомат и ложим в стек. Если это операция ’.’, ’+’ или ’’, то берем из стека нужное количество автоматов и проводим соответствующую операцию над ним(и), и кладем результат в стек. Искомым автоматом будет оставшийся после всех опреций элемент стека. Если на вход дан неуказанный символ, в стеке не хватает элементов для текущей операции или в конце в стеке осталось больше одного элемента, то регулярное выражение считается неккоректным.
### Поиск длину самого длинного префикса u, принадлежащего L:
Проходимся dfs по автомату по буквам слова u. При попадании в конечную вершину, обновляем значение самого длиного префикса.
### О проекте
main.cpp - для покрытия тестами
main1.cpp - для stdin, stdout
